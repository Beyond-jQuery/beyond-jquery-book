# Using and Understanding HTML Element Attributes {#element-attributes}

Here in chapter five, prepare yourself for a full-scale, in-depth, no-holds-barred discussion on everything related to element attributes. All that you learned in the ["finding elements" chapter](#finding-elements) will prove to be useful as I will need to build on some of this knowledge in an effort to help you discover attributes. Here, I'll be sure you have a [proper understanding of attributes](#what-are-attributes), as well [how they came about and became part of HTML, and how they fit into the web API](#attribute-history). Additionally, you'll learn how to [use attributes to locate DOM elements](#finding-elements-with-attributes). While this was covered a bit in the ["finding elements" chapter](#finding-elements), you'll find that the coverage _here_ is comprehensive. And finally, I'll dive deeper into attributes and cover how you can [read, add, and update them on any DOM element](#reading-attributes). Special sections on [`data-`](#data-attributes), [`style`](#style-attribute), and [`class`](#class-attributes) attributes will be included as well.

Other than two exceptions, all of the web API code in this chapter has full support across _all_ [modern browsers](#modern-browsers) _and_ even Internet Explorer 8. And for those couple that do not have wide browser support, there is an equally elegant solution available for one, and a relatively straightforward approach for the other. After you complete this chapter, you will not only have a complete understanding of attributes, but you will also have the confidence to read, update, and use them to select elements all browsers, even those as old as Internet Explorer 8. Read on to continue your quest to move beyond jQuery.


## What is an attribute? {#what-are-attributes}

HTML elements, declaratively speaking, are made up of three parts: name, content, and attributes, with the last two being optional. Take a look at the following simple fragment, which I'll reference as I explain these three parts a bit more.

{title="html tags are made up of three parts", lang=html}
~~~~~~~
<form action="/rest/login.php" method="POST">
   <input name="username" required>
   <input type="password" name="password" required>
</form>
~~~~~~~

In the above markup, you see three elements: one `<form>` and two `<input>`s. The `<form>` element has a tag name of "form". In fact, `tagName` is a property available on every object in the DOM that implements the `Element` interface. This property was [standardized as part of W3C's DOM Level 2 Core specification][element.tagname]. In my above HTML, the `<form>` element, represented as a [`HTMLFormElement` object][html5-form], has a `tagName` of "form". The two `<input>` elements are represented as [`HTMLInputElement` objects][html5-input], and unsurprisingly they have `tagName` values of "input".
   
Content describes any other node that are are descendants of an element. My example `<form>` has two `<input>` elements as content, while the two `<input>` elements have _no_ content. In fact, `<input>` elements are not allowed to have any content. This restriction was likely in place since `<input>` elements were first introduced in [the HTML 2 specification][html2], but was only first [explicitly mentioned in the HTML 3 official standard document][html3].
   
I> ## A note about my example form markup
I>
I> Normally you would want to associate each form field with a `<label>` and a text node with a display name. Also, a submit button is usually prudent, but I left all of these out of my fragment to keep it simple and focused on the discussion of attributes.

Attributes, also optional, provide a way to annotate elements directly in your markup. You may use them to provide data or state. For example, the `<form>` element above contains two such attributes: `action` and `method`, which together tell the form to send a POST request (`method`) to the "/rest/login.php" server endpoint (`action`) when the form is submitted. The first input has a `name` attribute of "username" and the second has a `name` of "password". This information is used to construct the request and tie these elements to their values when the server parses the form submit. This is not evident in the above HTML, but you can even create your own proprietary attributes and reference them in your code for the purposes of associating state or data with elements in your markup. Though not strictly required, the more standard way to do this is with `data-` attributes, which [will be discussed later on in this chapter](#data-attributes).
   
In addition to providing data or state, some attributes are used to define specific behaviors for a more general element. Take a look at the `type` attribute on the second input in the above fragment, as an example of this. This `type` attribute defines the second input to be a password input, which signals the browser to mask any characters entered into this field by the user. The first input _could_ include a `type` attribute with a value of "text", but this is not necessary as all `<input>` elements are, by default, text inputs. This default has been in place since the inception of HTML, and [is visible in one of the earliest drafts of the specification][html1-input]. Another example of a behavior imposed by an attribute can be seen on both of the inputs above. Notice the `required` attributes on each of the inputs - this is a signal to any browser that supports [the `constraints API`][html5-constraints] to prevent form submission if either of these fields are left empty by the user. 


### History and standardization {#attribute-history}

Attributes have always been a part of HTML, and were [described in the first document that details HTML tags][html-tags], written by Tim Berners-Lee in 1992. In this article, Berners-Lee describes the same two general types of attributes that are used in HTML today  - boolean, and variable - which I will elaborate on further shortly. The passage that calls out attributes is near the start of the document:

> Some tags take parameters, called attributes. The attributes are given after the tag, separated by spaces. Certain attributes have an effect simply by their presence, others are followed by an equals sign and a value.

Berners-Lee went on to mention a few such attributes, using the `href`, `type`, and `name` attributes of anchor tags as an example. Note though that the `name` attribute on `<a>` elements is no longer available as [it was removed in the HTML5 specification][html5-anchor]. Since this first description of HTML, the number and importance of element attributes has increased greatly.

Purely custom attributes are not, and have never been _officially_ supported in any HTML specification. But you may prefix an attribute name of your choice with "data-" as of the HTML5 spec - more on that [later](#data-attributes). However, if you would like to introduce a purely custom attribute into your markup, such as "myproject-uuid", you are certainly free to do so. The page will render without issue, and there will be no errors in your browser's developer tools console. Everything will work just fine. The only drawback is that your document will fail validation, as it will contain non-standard attributes, that is, attributes that are not mentioned in any accepted HTML standard. In fact, non-standard custom attributes are quite common, and even quite prevalent in popular JavaScript frameworks, such as AngularJS, which relies on non-standard custom attributes heavily to facilitate communication between element directives.

{#boolean-attributes}
The latest _completed_ HTML spec - HTML5 - defines [four different types of attributes][html5-attribute-syntax]. One type commonly known as a ["boolean attribute"][html5-boolean-attribute] is expressed as an element attribute without any value. Take the `required` attribute commonly found on `<input>` elements as one example (seen in the [previous section's](#what-are-attributes) HTML fragment). As the specification states, "The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value." The HTML 5.1 standardized [`hidden` attribute][html51-hidden], which instructs the browser to _not_ render any element bearing the attribute, is another example of this first type.

A second type of attribute is described as "unquoted". A little known fact is that you may omit quotes around your attribute values, provided the attribute value does not contain spaces, equal signs, or angle brackets (`<` and `>`), or an empty string (among other less notable character restrictions). So, the HTML fragment in the previous section can be re-written as follows:

{title="unquoted attributes are perfectly legal", lang=html}
~~~~~~~
<form action=/rest/login.php method=POST>
   <input name=username required>
   <input type=password name=password required>
</form>
~~~~~~~

The final two types of HTML element attributes are very similar: single-quoted and double-quoted. Both are similar in that they largely have the same restrictions, and are much more common than unquoted attributes. Though, double-quoted attributes are arguably the _most_ common of all types. In contrast to unquoted attribute values, those that are surrounded by either single or double quotation marks _may_ contain spaces, equal signs, angle brackets, or an empty string. The portion of the latest W3C specification that describes attributes only may never contain any ambiguous ampersand characters, that is, an `&` sign followed by ASCII characters and terminated with a semicolon (`;`) where the character code does _not_ match any character codes defined in the [named character references][html5-named-character-references] portion of the spec.


### How do attributes differ from properties?

Now that you have a solid understanding of element attributes, you may _still_ be confused regarding their relation to element "properties", _especially_ if you have been [using jQuery for a while][jquery-16]. At a very basic level, properties and attributes are entirely different from each other. While attributes are declared at the HTML level in the element's markup, properties are declared and updated on the element's object representation. For example, consider the following element:

{title="element for attributes vs properties explanation", lang=html}
~~~~~~~
<div class="bold">I'm a bold element</div>
~~~~~~~

The `<div>` has a `class` attribute with a value of "bold". But we can set properties on this element too. Suppose we want to set a property of `index` with a value of `0`:
   
{title="setting an element property", lang=html}
~~~~~~~
<div class="bold">I'm a bold element</div>

<script>
   document.querySelector('.bold').index = 0;
</script>
~~~~~~~

After executing the above fragment, our `<div>` now has a `class` attribute with a value of "bold" _and_ a property of `index` with a value of `0`. The property is set on the underlying JavaScript object, which in this case is an implementation of the [`HTMLDivElement`][htmldivelement] interface. Properties such as our `index` on element objects are also known as "expando" properties, which is just a terse way to classify non-standard element object properties. Understand that not _all_ element properties are expando properties. Don't worry if this is still not entirely clear. I'll talk more about standardized element properties before this section is complete.

While properties and attributes are conceptually and syntactically different, they are very closely linked together in some cases. In fact, all standardized element attributes have corresponding properties defined in the element's object representation. For the most part, the each attribute and property pair share the same value. And in all but one case, the attribute and property share the same name as well. These standardized attributes are special in that you can update them without touching the markup. In fact, updating the corresponding element object's property value will cause the browser to update the attribute's value in the document, and updating the attribute value with in turn up the element's property value. Let's take a look at a simple example, where we define an anchor link with an initial `href`, and then update the anchor to point to a different location using JavaScript:

{title="standard element attributes and properties are linked", lang=html}
~~~~~~~
<a href="http://www.widen.com/blog/">Read the Widen blog</a>

<script>
   document.querySelector('A').href = 'http://www.widen.com/blog/ray-nicholus';
</script>
~~~~~~~

After executing the script in the above code block, the anchor now appears in the document as follows:

{title="after updating the href property in the previous example", lang=html}
~~~~~~~
<a href="http://www.widen.com/blog/ray-nicholus">Read the Widen blog</a>
~~~~~~~

In this case, the [`HTMLAnchorElement`][html51-a], which is the object representation of an `<a>`, has an `href` property defined on its prototype that is directly connected to the `href` attribute on the element tag. Note that this `href` property is actually inherited from the [`URLUtils` interface][whatwg-urlutils], which the `HTMLAnchorElement` object also implements. `URLUtils` is an interface formally defined in the [WHATWG URL Living Standard][whatwg-url] specification.
    
There are many such other element attributes with connected properties, such as `id` (all elements), `action` (form elements), and `src` (script elements), to name a few. Remember that all attributes that appear in the HTML specifications fall into this category. But there are a few special cases and points to consider. First, `class` attributes are a bit different in that the corresponding property name is not `class`, but `className`. This is due to the fact that ["class" is a reserved word in JavaScript][es6-reserved-words]. More on the `class` attribute [later on](#class-attributes). Also keep in mind that the `checked` attribute, common to radio and checkbox input elements, is only _initially_ connected to the corresponding element property value. Consider the following code to demonstrate this limitation a bit more clearly:

{title="the checked boolean attribute is a bit unusual", lang=html}
~~~~~~~
<input type="checkbox" checked>

<script>
    // this does not remove the checked attribute
    document.querySelector('INPUT').checked = false;
</script>
~~~~~~~

After executing the above script, you may expect the `checked` attribute to be removed from the input element, since this would happen for other boolean attributes, such as `required` and `disabled`. However, the `checked` attribute remains on the element, even though the property value has been changed to `false` and the checkbox is indeed unchecked.

"Custom" attributes, that is, attributes that are _not_ defined in any accepted specification, are not linked in this way to a similarly named property on the element object. Any properties you create to match non-standard attributes fall into the category of expando properties.


## Finding elements using attributes {#finding-elements-with-attributes}

Building upon the [class](#selecting-classes) and [ID](#selecting-ids) selector examples from [the previous chapter](#finding-elements), this section is going to provide a much more comprehensive guide to selecting any and _all_ attributes using the web API. While ID and class attribute selection is commonly accomplished using a syntax specific to these two types of attributes, you are able to use the more general attribute selection approaches found in this chapter as well. In some cases, some of the generic but powerful attribute selectors demonstrated here are most appropriate when looking for multiple elements by ID or class that follow a known pattern.

For the sake of consistency and reference, jQuery examples will be provided throughout this section. But attributes can be selected in a number of ways without jQuery, simply by using either `querySelector` or `querySelectorAll`. Since attribute selectors were first introduced as [part of the W3C CSS 2 specification][css2-attributes] **all of the simple web API examples here are supported all the way back to Internet Explorer 8**! You truly don't need jQuery to write simple but powerful attribute selectors.
   
   
### Finding elements using attribute names

We'll cover values in quite a bit of detail shortly, but let's first focus on attribute names. Why might you want to only focus on an attribute name? Perhaps for many reasons, including:

1. Locating `disabled` elements or `required` form fields.
2. Finding one or more elements that include a custom attribute that groups these elements in some way.
3. Locating invalid markup in a document, such as `<img>` elements without a `src` attribute.

The following jQuery and web API examples will revolve around #1 above. For this, a small HTML fragment will be used for reference:

{title="selecting attributes by name - sample HTML", lang=html}
~~~~~~~
<form action="/submitHandler.php" method="POST">
    <input name="first-name">
    <input name="last-name" required>
    <input type="email" name="email" required>
    <button disabled>submit</button>
</form>
~~~~~~~


#### jQuery

There is one way to select elements given their attributes in jQuery, and that is by passing a valid CSS 2+ attribute selector string into the jQuery function:

{title="selecting by attribute name - jQuery", lang=javascript}
~~~~~~~
var $result = $('[required], [disabled]');
~~~~~~~

The above code will result in a `$result` jQuery object that contains the "last-name", "email" `<input>` elements, along with the disabled submit `<button>`. In case the comma in the selector string is causing you some confusion, I covered this in [the previous chapter's multiple element selector section](#multiple-selectors). This jQuery code relies entirely on the web API. 


#### Web API

As with many of the native solutions in the ["finding elements" chapter](#finding-elements), the code required to locate elements using attribute names is eerily similar to the jQuery solution you have just seen. 

{title="selecting by attribute name - web API - all modern browsers + IE8", lang=javascript}
~~~~~~~
var result = document.querySelectorAll('[required], [disabled]');
~~~~~~~

Similar to the jQuery example, the above code will populate the `result` variable with a `NodeList` containing the "last-name" and "email" inputs, along with the disabled submit button. 

{#empty-class-attribute}
While `disabled` and `required` are [boolean attributes](#boolean-attributes), the above code will yield the same results even if we assigned them values. The attribute selector simply matches on the attribute name - the value (or lack of one) is irrelevant. This means you can easily locate all elements in a document that have CSS classes assigned to them. For example, look at the following simple attribute selector:

{title="selecting all elements with a class attribute - modern browsers + IE8", lang=javascript}
~~~~~~~
var result = document.querySelectorAll('[class]');
~~~~~~~

Given the following HTML:

{title="elements with and without CSS classes", lang=html}
~~~~~~~
<div class="bold">I'm bold</div>
<span>I'm not</span>
~~~~~~~

...the `result` variable in the previous selector will yield one element - the `<div>`. But beware, simply adding an _empty_ `class` attribute to the `<span>` may result in an unexpected result set:
   
{title="elements with and without CSS classes", lang=html}
~~~~~~~
<div class="bold">I'm bold</div>
<span class>I'm not</span>
~~~~~~~

Even though the `<span>` does not have any CSS classes assigned to it, the mere presence of the `class` attribute means that our selector includes it in the result set alongside the `<div>`. This is probably not what we wanted. This is not a deficiency of the selector API, but it _is_ important to understand exactly how attribute name selectors function. Note that you will run into the same "problem" using jQuery if you don't have a firm grasp of this CSS selector.


### Finding elements using attribute names _and_ values

Sometimes locating an element or group of elements by attribute name alone is not sufficient. You may want to, for example, locate all password input fields, in which case you would need to find all `<input>` elements with a `type` attribute of "password". Or perhaps you need to located all anchor elements that link to a specific endpoint, in which case you'd need to key on the desired value of the `href` attribute of all `<a>` elements. 

To setup our jQuery and web API examples, let's use the following HTML and state that our goal is to locate all anchors that link to the ajax-form web component documentation page.

{title="elements with and without CSS classes", lang=html}
~~~~~~~
<section>
   <h2>web components</h2>
   <ul>
       <li>
           <a href="http://file-input.raynicholus.com/">file-input</a>
       </li>
       <li>
           <a href="http://ajax-form.raynicholus.com/">ajax-form</a>
       </li>
   </ul>
</section>
<section>
   <h2>no-dependency libraries</h2>
   <ul>
      <li>
          <a href="http://ajax-form.raynicholus.com/">ajax-form</a>
      </li>
      <li>
          <a href="http://fineuploader.com/">Fine Uploader</a>
      </li>
   </ul>
</section>
~~~~~~~


#### jQuery

In order to find all anchor elements that point to the ajax-form library page, we'll use a standardized CSS selector string passed into the `jQuery` function, as we've seen so many times before:

{title="find anchors with specific href attributes - jQuery", lang=javascript}
~~~~~~~
var $result = $('A[href="http://ajax-form.raynicholus.com/"]');
~~~~~~~

The above selector returns a jQuery object containing the two ajax-form `HTMLAnchorElement` objects from our example markup.
 

#### Web API

You've already seen how a standard CSS selector is required to select by attribute name and value when using jQuery, so of course the same selector is most appropriate when attempting to find specific anchor elements without jQuery. The solution here is, as you have seen in most other element selection examples, almost identical to the jQuery approach, but more efficient:

{title="find anchors with specific href attributes - web API - modern browsers + IE8", lang=javascript}
~~~~~~~
var result = 
    document.querySelectorAll('A[href="http://ajax-form.raynicholus.com/"]');
~~~~~~~

The `result` variable is a `NodeList` containing both ajax-form anchors from our example HTML at the start of this section. Support for this simple but effective selector is part of the [W3C CSS 2 selector specification][css2-attributes], so even Internet Explorer 8 is supported. Note that I'm combining the attribute name/value selector with a [tag name selector](#tag-selector). This ensures that any other elements that may include a non-standard `href` attribute are ignored (along with any `<link>` elements), since we are only concerned with anchor links.

Remember the [empty class attribute example](#empty-class-attribute) from the selecting by attribute name section? During our search for all elements with CSS classes, we were unable to ignore empty `class` attributes with a simple attribute name selector. But if we pair an attribute name/value selector with the [exclusion selector from the "finding elements chapter"](#excluding-elements), we can effectively filter out empty `class` attributes:

{title="find anchors with specific href attributes - web API - modern browsers", lang=javascript}
~~~~~~~
var result = document.querySelectorAll('[class]:not([class=""]');
~~~~~~~

Using the sample HTML from the initial [empty class attribute example](#empty-class-attribute) section, the above code block, `result` contains a `NodeList` containing _only_ the `<div>` with a `class` attribute of "bold". The `<span>` with an empty `class` attribute has been skipped over.


### The power of wildcard and fuzzy attribute selectors

%%- [att|=val]
%%Represents an element with the att attribute, its value either being exactly "val" or beginning with "val" immediately followed by "-" (U+002D). This is primarily intended to allow language subcode matches (e.g., the hreflang attribute on the a element in HTML) as described in BCP 47 ([BCP47]) or its successor. For lang (or xml:lang) language subcode matching, please see the :lang pseudo-class.

%% -[att^=val]
%%Represents an element with the att attribute whose value begins with the prefix "val". If "val" is the empty string then the selector does not represent anything.

%%- [att$=val]
%%Represents an element with the att attribute whose value ends with the suffix "val". If "val" is the empty string then the selector does not represent anything.

%%- [att*=val]
%%Represents an element with the att attribute whose value contains at least one instance of the substring "val". If "val" is the empty string then the selector does not represent anything.


## Reading and modifying element attributes {#reading-attributes}

%%- three types of attributes: class, data, and everything else

%%- parsing, adding, removing, and changing attributes can differ depending on type


### Class attributes {#class-attributes}

%%- reading classes ("hasClass")

%%- adding / removing classes

%%- toggleClass


### Data attributes {#data-attributes}

%%- data attributes (more about this in the html-data.txt chapter)


### Other standard and custom attributes

%%- reading attributes ("hasAttribute", "getAttribute")

%%- adding / removing / changing attributes


### The `style` attribute {#style-attribute}

%%- normally shouldn't use this - more about styling in the styling-elements.txt chapter)


[css2-attributes]: http://www.w3.org/TR/CSS2/selector.html#attribute-selectors

[element.tagname]: http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-104682815

[es6-reserved-words]: http://www.ecma-international.org/ecma-262/6.0/#sec-keywords

[html1-input]: http://www.w3.org/MarkUp/HTMLPlus/htmlplus_41.html

[html2]: http://www.w3.org/MarkUp/html-spec/html-spec_toc.html

[html3-input]: http://www.w3.org/MarkUp/html3/input.html

[html5-anchor]: http://www.w3.org/TR/html5/text-level-semantics.html#the-a-element

[html5-attribute-syntax]: http://www.w3.org/TR/html5/syntax.html#attributes-0

[html5-boolean-attribute]: http://www.w3.org/TR/html5/single-page.html#boolean-attributes

[html5-constraints]: http://www.w3.org/TR/html5/forms.html#constraints

[html5-form]: http://www.w3.org/TR/html5/forms.html#the-form-element

[html5-input]: http://www.w3.org/TR/html5/forms.html#the-input-element

[html5-named-character-references]: http://www.w3.org/TR/html5/syntax.html#named-character-references

[html51-a]: http://www.w3.org/TR/html51/semantics.html#the-a-element

[html51-hidden]: http://www.w3.org/TR/html51/editing.html#the-hidden-attribute

[html-tags]: http://www.w3.org/History/19921103-hypertext/hypertext/WWW/MarkUp/Tags.html

[htmldivelement]: http://www.w3.org/TR/html5/grouping-content.html#the-div-element

[jquery-16]: http://blog.jquery.com/2011/05/03/jquery-16-released/

[whatwg-url]: https://url.spec.whatwg.org

[whatwg-urlutils]: https://url.spec.whatwg.org/#urlutils